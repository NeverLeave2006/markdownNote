# 变量

## 变量声明

```golang
var name string
var age int 
var isOk bool

//批量声明
var (
    name string
    age int
    isOk bool
)


```

## 变量初始化
声明变量同时赋值

```golang 
//初始化
var s1 string="sgdhkjasdjk"
//类型推导
var s2="fhasdofha"

//简短变量声明,只能在函数中使用
s3:="哈哈哈"

//匿名变量, 用于多返回值舍去一个值
x, _ :=foo()

```

> go语言中变量声明必须使用!
> 函数外的每个语句必须以关键字开始(var，const func)
> :=不能在函数外使用
> _多用于占位,表示忽略值（多重赋值）


占位符
```golang
printf("%S"，name);
```

> 推荐驼峰，小驼峰命名

## 常量
定义后不能修改,不能赋值的量
```golang

//声明常量
const pi=3.141592654
const e=2.71828

//批量声明
const(
    statusOk=200
    notFound=404
)

const(
    n1=100
    n2//默认和上面一行一样，都是100
    n3
)
```

## iota
iota是go语言常量计数器,只能在常量的表达式中使用。
iota在const关键字中出现时将被重置为0，const中每新增一行声明将使iota计数一次,(iota可理解为const语句块中的行索引)。 使用iota能简化定义, 在**定义枚举**时很有用。

```golang
const(
    n1=iota
    n2
    n3
    n4
)

const(
    a1=iota//0
    a2     //1
    _      //2
    a4     //3
)

//插队
const(
    a1=iota//0
    a2=100 //100,但是不影响下面的值
    a3     //2
    a4     //3
)

//多个常量声明在一行,出现为0，加一行加1
const(
    d1,d2=iota +1,iota+2//d1:1,d2:2
    d3,d4=iota +1,iota+2//d3:2,d4:3
)

//应用:定义数量级
const(
    _ =iota
    KB=1<<(10*iota)
    MB=1<<(10*iota)
    GB=1<<(10*iota)
    TB=1<<(10*iota)
    PB=1<<(10*iota)
)
```
## Go 基本数据类型

### 整型
分为带符号和无符号两大类
|整型|描述|
|:----|:----|
|uint8|无符号8位整型|
|uint16|无符号168位整型|
|uint32|无符号32位整型|
|uint64|无符号64位整型|
|int8|有符号8位整型|
|int16|有符号16位整型|
|int32|有符号32位整型|
|int64|有符号64位整型|

特殊整型
|类型|描述|
|:----|:----|
|uint|32位系统上是uint32，64位系统上是uint64(不建议使用)|
|int|32位系统上是int32，64位系统上是int64(不建议使用)|
|uintptr|无符号整型,用于存放一个指针|

- 八进制和十六进制
```go
package main

import "fmt"

//导入语句

//函数入口
func main() {
	//十进制
	var a int = 10
	fmt.Printf("%d \n", a) //十进制 10
	fmt.Printf("%b \n", a) //二进制1010

	//八进制,以0开头
	var b int = 077
	fmt.Printf("%o \n", b) //77

	//十六进制, 以0x开头
	var c int = 0xff
	fmt.Printf("%x \n", c) //ff
	fmt.Printf("%X \n", c) //FF

    //查看变量类型
	fmt.Printf("%t \n", a)
	fmt.Printf("%t \n", b)
	fmt.Printf("%t \n", c)
}

```

### 浮点型
```go
package main

import "fmt"

func main() {
	f1 := 1.23456
	fmt.Printf("%T\n", f1) //默认float64位
	f2 := float32(1.23456)
	fmt.Printf("%T\n", f2) //float64

	//f2不能赋值给f1，类型不同不能直接转

}
```

### 复数
```go
package main

import "fmt"

func main() {
	var c1 complex64
	c1 = 1 + 2i
	var c2 complex128
	c2 = 2 + 3i
	fmt.Println(c1)
	fmt.Println(c2)
}
```


### 布尔型
Go语言中以`bool`类型进行声明布尔型数据,布尔型数据只有`true(真)`和`false(假)`两个值

注意:
    1. 布尔值变量默认值为false
    2. Go语言中不允许将整型强制转换为布尔型
    3. 布尔型无法参与数值运算也无法与其他类型进行转换

```go
package main

import "fmt"

func main() {
	b1 := true
	var b2 bool
	fmt.Printf("%T\n", b1)
	fmt.Printf("%T value:%v\n", b2, b2)
}

```

#### fmt总结
```go
package main

import "fmt"

func main() {
	var n = 100
	fmt.Printf("%T\n", n)
	fmt.Printf("%v\n", n)
	fmt.Printf("%b\n", n)
	fmt.Printf("%d\n", n)
	fmt.Printf("%o\n", n)
	fmt.Printf("%x\n", n)
	var s = "fuck gmy"
	fmt.Printf("字符串: %s\n", s)
	fmt.Printf("字符串: %v\n", s)
	fmt.Printf("字符串: %#v\n", s)
}

```

### 字符串
Go语言中的以原生数据类型出现, 使用字符串就像使用其他原生数据类型(int,bool,float32,float64等)一样。Go语言里的字符串内容实现使用`UTF-8`编码。字符串的值为`双引号"`中的内容(只能用双引号),可以在Go语言的源码中直接添加非ASCII吗字符,例如:
```go
s1:="hello"
s2:="你好"
```
单引号包裹的是字符,可以是字母,汉字


字符串转义符
|转义符|含义|
|:----|:----|
|\r|回车符(返回行首)|
|\n|换行符(直接跳到下一行的同列位置)|
|\t|制表符|
|\\'|单引号|
|\\\\ |反斜杠|



#### 字符串常用操作
|方法|介绍|
|:----|:----|
|len(str)|求长度|
|+或fmt.Sprintf|拼接字符串|
|string.Split|分割|
|strings.contains|判断是否包含|
|stringsHasPrefix,strings.HasSuffix|前后缀判断|
|strings.Index(),strings.LastIndex()|子串出现的位置|
|strings.Join(a[]string,sep string)|join操作|


```go
package main

import (
	"fmt"
	"strings"
)

//字符串

func main() {
	// 、本来是具有特殊含义的,应该使用转义字符
	path := "\"D:\\CodingPractise\\go\""
	fmt.Println(path)

	s := "I'm Ok"
	fmt.Println(s)

	//多行的字符串
	s2 := `
秦王扫六合，
虎视何雄哉。
挥剑决浮云，
诸侯尽西来。
	`
	fmt.Println(s2)

	//字符串相关操作

	//长度
	fmt.Println(len(s2))

	//拼接
	name := "理想"
	world := "comes"
	fmt.Println(name + world)
	ss1 := fmt.Sprintf("%s%s", name, world) //返回合并的字符串
	fmt.Println(ss1)

	//分隔
	ret := strings.Split(path, "\\")
	fmt.Println(ret)

	//包含
	fmt.Println(strings.Contains(ss1, "理"))

	//前缀
	fmt.Println(strings.HasPrefix(ss1, "理"))
	//后缀
	fmt.Println(strings.HasSuffix(ss1, "理"))

	//子串出现的位置
	s4 := "abcdefghijilmnasdgfadhgfgfahajtawetrsfdopqrstuvwxyz"
	fmt.Println(strings.Index(s4, "a"))
	fmt.Println(strings.LastIndex(s4, "a"))

	//拼接
	fmt.Println(strings.Join(ret, "+"))
}

```

#### byte和rune类型


### 数组

### 切片

### 结构体

### 函数

### map

### 通道
