# 线程的概述
## 线程相关概念
- 进程: 是计算机中的程序关于数据集合上的一次活动，是操作系统进行资源分派与调度的基本单位
可以把进程简单理解为正在操作系统中简单允许的一个程序

- 线程: 进程的一个执行单元
一个线程就是进程中一个单一顺序的执行流，进程的一个执行分支，进程是线程的容器，一个进程至少有一个线程，一个进程中也可以有多个线程
在操作系统中以进程为单位分配资源，如虚拟存储空间，文件描述符等，每个线程都有各自的线程栈，自己的寄存器环境，自己的线程本地存储


- 主线程和子线程
JVM启动时会创建一个主线程，该主线程负责执行main方法
java中的线程不是孤立的，线程间存在一些联系。如果在A线程中创建了B线程，称B线程为A线程的子线程，相应的A线程就是B线程的父线程

- 串行，并发与并行
  - 串行sequential,先做任务A,完成后再做任务B,完成后在做任务C,所有任务逐个完成，共耗时15+10+10=35分钟
  - 并发(concurrent),先做任务A,在A等待期间做任务B,B准备期间做任务C,耗时5+2+10=17分钟
  - 并行(parallel),三个任务同时开始，总耗时取决于需要时间最长的那个任务
    并发可以提高对事务的处理效率，即一段时间内可以完成更多的事情
    并行是一种更严格离线的并发
    从硬件角度来说，如果单核CPU，一个处理器一次只能执行一个线程的情况下，处理器可以使用时间片轮转技术，可以让CPU快速的在各个线程之间进行切换，对于用户来说感觉是三个线程在同步执行，如果是多核心CPU,可以为不同的线程分配不同的CPU内核，

## 线程的创建与启动
在java中创建一个线程就是创建一个Thread类(子类)的对象(实例).

Thread类有两种常用的构造方法: Thread()与Thread(Runnable).对于创建线程的两种方式:
    定义Thread类的子类
    定义一个Runnable接口的实现类
    这两种创建线程的方式没有本质的区别

## 线程的常用方法
### currentThread()方法
Thread.currentThread()可以获取当前线程,执行当前代码的线程就是当前线程
同一段代码可能被不同的线程执行，因此当前的线程是相对的，Thread.currentThread()返回代码实地允许的线程对象


### setName()/getNmae()
thread.setName(线程名称)//设置线程名称
thread.getName()//返回线程名称
通过设置线程名称提高程序可读性

### isAlive()
isAlive()判断当前线程是否处于活动状态
活动状态就是线程已经启动但是还没有终止

### sleep()
Thread.sleep(millis);让当前线程休眠指定的毫秒数
当前线程是指Thread.currentThread()返回的线程

在run方法中如果由编译时异常只能选择捕获处理，不能抛出处理

### getId()
Thread.getId(): 可以获得线程的唯一标识
注意:
某个编号的线程允许结束后，该编号可能被后续创建的线程使用
重启JVM后，同一个线程的编号可能不一样

### yield()
Thread.yield()方法的作用是放弃当前的CPU资源

### setPriority()
Thread.setPriority(num)设置线程优先级
java线程的优先级取值范围是1-10，超出范围会抛出illegalArgumentException.
在操作系统中，优先级较高的线程获得CPU资源越多
线程优先级本质上只是给线程调度器一个提示信息，以便于调度器决定先调度那些线程，注意不能保证优先级高的线程先运行
java优先级设置不当或者滥用会导致某些线程永远得不到允许，会导致线程饥饿
线程优先级并不是设置的越高越好，一般情况下使用普通的优先级即可，即在开发时不必设置线程的优先级
线程的优先级既有继承性，在A线程中创建了B线程，则B线程的优先级与A线程是一样的

### interrupt()
可以中断线程
调用interrupt()方法仅仅是在当前线程打一个停止标志，并不是真正停止线程
isInterrupted()//判断线程是否被标记为中断

### setDaemon(bool)
java中的线程分为用户线程和守护线程
守护线程是为其他线程服务的线程，例如垃圾回收去(gc)是一个典型的守护线程
守护线程不能单独运行，当JVM中没有其他线程，只有守护线程时，守护线程会自动销毁，JVM会退出
设置守护线程的代码应该在线程启动前

## 线程的生命周期
线程的生命周期是线程对象的生老病死，即线程的状态
线程生命周期可以通过getState()方法获得, 线程的状态是thread.state枚举类型定义的，由以下几种:
NEW新状态，创建了线程对象，在调用start()启动之前的状态;
RUNNABLE,可运行状态，包含ready和running两个状态
  - ready状态表示该线程可以被线程调度器调度使用
  - running状态表示该线程正在执行。Thread.yield()可以将running状态转为ready状态
  - blocked阻塞状态。线程发起阻塞IO操作，或者申请其他线程的独占资源，线程转为blocked状态，处于阻塞状态的线程不会占用cpu资源。当阻塞I/O操作执行完成，或者线程获得了其申请的资源，线程可以转换为Runnable
  - waiting 等待状态。线程执行了object.wait(),thread.join()方法会把线程转换为waiting等待状态，执行object.notify()方法，或者加入的线程执行完毕，当前线程会转换为runnable状态
  - timed_waiting状态，与waiting状态类似，都是等待状态。区别在于该状态的线程不会无限等待，如果线程没有在指定的时间范围完成期望的操作，该线程自动转换为runnable
  - terminated终止状态，线程结束处于终止状态
  
![java线程状态转换图](java线程状态转换图.jfif)
## 多线程的优势与存在的风险
多线程编程具有以下优势：
  1. 提高系统的吞吐率(Throughout). 多线程编程可以使一个进程有多个并发(concurrent, 即同时运行)的操作
  2. 提高响应性(Responsiveness). Web服务器会采用专门的线程负责用户的请求处理，缩短了用户等待时间
  3. 充分应用多核(multicore)处理器资源。 通过多线程可以充分利用CPU资源

多线程编程存在的问题与风险:
  1.  线程安全(Thread safe)问题. 多线程共享数据时, 如果没有采取正确的并发访问控制措施， 就可能会产生数据一致性问题, 如读取脏数据(过期的数据), 如丢失数据更新. 
  2.  线程活性问题(thread liveness)问题. 由于程序自身的缺陷或者由资源稀缺性导致线程一直处于非runnable状态，这就是线程活性问题, 常见的活性故障有以下几种:
      1.  死锁(DeadLock). 类似鹬蚌相争.
      2.  锁死(Lockout),类似于睡美人中王子挂了
      3.  活锁(livelock)，类似于小猫咬自己的尾巴
      4.  饥饿(Satrvation),类似于健壮的雏鸟总是从木鸟嘴中抢到事务
  3.  上下文切换(context switch). 处理器从执行一个线程切换到执行另外一个线程
  4.  可靠性. 可能会有一个线程导致JVM意外终止，其它的线程也无法执行.

# 线程安全问题
非线程安全主要是多个线程对同一个对象的示例变量进行操作时，会出现值被更改，值不同步的情况.
线程安全问题表现为三个方面: 原子性，可见性和有序性

## 原子性
原子(Atomic)就是不可分割的意思. 原子操作的不可分割有两层含义:
  1. 访问(读，写)某个变量的操作从其他线程来看, 该操作要么已经执行完毕，要么尚未发生，即其他线程看不到当前线程的中间结果
  2. 访问同一组共享变量的原子操作是不能够交错的，如现实中从ATM机取款，对于用户来说，要么操作成功，用户拿到钱，余额减少了，增加一条交易记录;要么没拿到前，相当于取款操作没有发生

java 有两种方式实现原子性: 一种是使用锁; 另一种是利用处理器的CAS(Comapre and Swap)指令
锁具有排他性, 保证共享变量在某一时刻只能被一个线程访问
CAS指令直接在硬件(处理器和内存)层次上实现，看作是硬件锁。

AtomicInteger 原子integer类，保证线程安全

## 可见性
在多线程环境中，一个线程对某个变量进行更新后，后续其他线程可能无法立即读到这个更新结果，这就是线程安全问题的另外一种形式:可见性(visibility)
如果一个线程对变量更新后，后续访问变量的其他线程可以读到更新的结果，称这个线程对共享变量的更新对其他线程可见，否则称这个线程对共享变量的更新对其他线程不可见
多线程因为可见性问题可能导致其他线程读取到了旧数据(脏数据).

## 有序性
有序性(ordering)是指什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另一个处理器运行的其他线程看来是乱序的(out of order)
乱序是指内存访问操作的顺序看起来发生了变化
在多核处理器的环境下，编写的顺序结构，这种操作执行的顺序可能是没有保证的:
  编译器可能会改变两个操作的先后顺序;
  处理器也可能不会按照目标代码的顺序执行;
  这种一个处理器上执行多个操作，在其他处理器看来它的顺序与目标代码指定的顺序可能不一样，这种现象称为重排序。
  重排序是对内存访问操作的一种优化，可以在不影响单线程程序正确的前提下提升程序的性能。但是，可能对多线程程序的正确性产生影响，即可能导致线程安全问题
  重排序和可见性类似，不是必然出现的问题

与内存操作顺序有关的几个概念:
  源代码顺序, 就是源码中指定的内存访问顺序
  程序顺序, 处理器上运行的目标代码所指定的内存访问顺序
  执行顺序, 内存访问操作在处理器上的实际执行顺序
  感知顺序, 给定处理器所感知到的该处理器即其他处理器的内存访问操作的顺序

  可以把重排序分为指令重排序和存储子系统重排序两种.
  指令重排序主要是指由jit编译器，处理器引起的，指程序顺序与执行顺序不一样
  存储子系统重排序是由高速缓存, 写缓冲器引起的, 感知顺序与执行顺序不一致

- 指令重排序
  在源码顺序与程序顺序不一致, 或者程序顺序与执行顺序不一致的情况下，我们就说发生了指令重排序(Instruction Reorder).
  指令重排是一种动作，确实对指令的顺序进行了调整，重排序的对象的指令
  javac编译器一般不会执行指令重排序，而jit编译器可能执行指令重排序
  处理器也可能执行指令重排序，使得执行顺序与程序顺序不一致

  指令重排不会对单线程程序的结果正确性产生影响，可能导致多线程程序导致非预期的结果


- 存储子系统重排序
  存储子系统是指写缓冲器与高速缓存
  高速缓存(Cacahe)是CPU中为了匹配与主存处理速度不匹配而设计的一个高数缓存
  写缓冲器(Store buffer, Write buffer)用来提高写告诉缓存操作的效率

  即使处理器严格按照程序顺序执行两个内存访问操作，在存储子系统的作用下，其他处理器对这两个操作的感知顺序与程序顺序也可能不一致，即这两个操作的执行顺序看起来像是发生了变化，这种现象称为存储子系统重排序
  存储之子系统重排序并没有真正对指令执行顺序进行调整，而是造成一种指令执行顺序被调整的假象.
  存储子系统重排序的对象是内存操作的结果.

  从处理器角度来看，都内存就是从指定的RAM地址中加载数据到寄存器，称为Load操作; 写内存就是把数据存储到指定的地址表示的RAM存储单元中，称为Store操作，内存重排序由以下四种可能：
    - LoadLoad重排序, 一个处理器上先后执行两个读操作L1和L2, 其他处理器对两个内存操作的感知顺序可能是L2->L1
    - storestore重排序，一个处理器先后执行两个写操作W1和W2,其他处理器对这两个内存操作的感知顺序可能是W2->W1
    - LoadStore重排序，一个处理器先执行读内存操作L1再执行写内存操作W1，其他处理器对两个内存的感知顺序可能是W1->L1
    - StoreLoad重排序，一个处理器先执行写内存操作W1再执行读内存操作L1, 其他处理器对两个内存操作的感知顺序可能是L1->W1

  内存重排序与处理器微架构有关，不同架构的处理器所允许的内存重排序不同
  内存重排序可能会导致线程安全问题. 

- 貌似串行语义
  JIT编译器，处理器是按照一定的规则对指令，内存操作的结果进行重排序，给单线程程序造成一种假象---指令是按照源码的顺序执行的。这种假象称为貌似串行语义. 并不能保证多线程环境下程序的正确性
  为了保证貌似串行语义由数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才会被重排序。如果这两个操作(指令)访问同一个变量，且其中一个操作(指令)为写操作,那么这两个操作之间就存在数据以来关系(Data dependency).
  如果不存在数据依赖关系则可能重排序,如:
  存在控制依赖关系的语句允许重排. 一条语句(指令)的执行结果会决定另一条语句(指令)能否被执行,这两条语句(指令)存在控制依赖关系(Control Dependency). 如在if语句中允许重排，可能存在处理器先执行if代码块，再判断if条件是否成立

- 保证内存访问的顺序性
  可以使用volitile关键字, synchronized关键字实现有序性
  
## java内存模型
- 每个线程都有独立的栈空间
- 每个线程都可以访问堆内存
- 计算机CPU不直接从主内存中读取数据，CPU读取数据时，先把主内存数据读取到Cache缓存中，把Cache中的数据读取到Register寄存器中
- JVM中的共享数据可嫩会分配到Register寄存器中，每个CPU都有自己的Register寄存器，一个CPU不能读取其他CPU上的寄存器中的内容。如果两个线程分别运行在不同的处理器(CPU)上, 而这两个共享的数据被分配到寄存器上，会产生可见性问题。
- 即使JVM中的共享数据分配到主内存中，也不能保证数据的可见性，CPU不直接对主内存访问，二手通过Cache高速缓存上进行的。一个处理器上运行的线程对数据的更新可能是更新到处理器的写缓冲器(Store Buffer),还没有到达Cache缓存，更不用说主存了，另外一个处理器不能读取到该处理器写缓冲器上的内容，会产生运行在另外一个处理器上的线程无法看到该处理器对共享数据的更新。
- 一个处理器的Cache不能直接读取另外一个处理器的Cac和，但是一个处理器可以通过缓存一致性协议(Cache Coherence Protocol)来读取其他处理缓存中的数据，并将读取的数据更新到该处理器的Cacahe中，这个过程称为缓存同步，缓存同步使得一个处理器上运行的线程可以读取到另外一个处理器上运行的线程对共享数据所作的更新，即保障了可见性。为了保障可见性，必须使一个处理器对共享数据的更新最终被写入该处理器的Cache中，这个过程被称为冲刷处理器缓存

规定:
1. 每个线程的共享数据都存储在主内存中
2. 每个线程都有一个私有的本地内存(工作内存)，线程的工作内存是抽象的概念，不是真是存在的,它可能涵盖写缓冲器，寄存器，其他硬件的优化
3. 每个线程从主内存中把数据读取到本地工作内存中，在工作内存中保存共享数据的副本
4. 线程在自己的工作内存中处理数据，仅对当前线程可见，对其他线程是不可见的