# 线程的概述
## 线程相关概念
- 进程: 是计算机中的程序关于数据集合上的一次活动，是操作系统进行资源分派与调度的基本单位
可以把进程简单理解为正在操作系统中简单允许的一个程序

- 线程: 进程的一个执行单元
一个线程就是进程中一个单一顺序的执行流，进程的一个执行分支，进程是线程的容器，一个进程至少有一个线程，一个进程中也可以有多个线程
在操作系统中以进程为单位分配资源，如虚拟存储空间，文件描述符等，每个线程都有各自的线程栈，自己的寄存器环境，自己的线程本地存储


- 主线程和子线程
JVM启动时会创建一个主线程，该主线程负责执行main方法
java中的线程不是孤立的，线程间存在一些联系。如果在A线程中创建了B线程，称B线程为A线程的子线程，相应的A线程就是B线程的父线程

- 串行，并发与并行
  - 串行sequential,先做任务A,完成后再做任务B,完成后在做任务C,所有任务逐个完成，共耗时15+10+10=35分钟
  - 并发(concurrent),先做任务A,在A等待期间做任务B,B准备期间做任务C,耗时5+2+10=17分钟
  - 并行(parallel),三个任务同时开始，总耗时取决于需要时间最长的那个任务
    并发可以提高对事务的处理效率，即一段时间内可以完成更多的事情
    并行是一种更严格离线的并发
    从硬件角度来说，如果单核CPU，一个处理器一次只能执行一个线程的情况下，处理器可以使用时间片轮转技术，可以让CPU快速的在各个线程之间进行切换，对于用户来说感觉是三个线程在同步执行，如果是多核心CPU,可以为不同的线程分配不同的CPU内核，

## 线程的创建与启动
在java中创建一个线程就是创建一个Thread类(子类)的对象(实例).

Thread类有两种常用的构造方法: Thread()与Thread(Runnable).对于创建线程的两种方式:
    定义Thread类的子类
    定义一个Runnable接口的实现类
    这两种创建线程的方式没有本质的区别

## 线程的常用方法
### currentThread()方法
Thread.currentThread()可以获取当前线程,执行当前代码的线程就是当前线程
同一段代码可能被不同的线程执行，因此当前的线程是相对的，Thread.currentThread()返回代码实地允许的线程对象


### setName()/getNmae()
thread.setName(线程名称)//设置线程名称
thread.getName()//返回线程名称
通过设置线程名称提高程序可读性

### isAlive()
isAlive()判断当前线程是否处于活动状态
活动状态就是线程已经启动但是还没有终止

### sleep()
Thread.sleep(millis);让当前线程休眠指定的毫秒数
当前线程是指Thread.currentThread()返回的线程

在run方法中如果由编译时异常只能选择捕获处理，不能抛出处理

### getId()
Thread.getId(): 可以获得线程的唯一标识
注意:
某个编号的线程允许结束后，该编号可能被后续创建的线程使用
重启JVM后，同一个线程的编号可能不一样

### yield()
Thread.yield()方法的作用是放弃当前的CPU资源

### setPriority()
Thread.setPriority(num)设置线程优先级
java线程的优先级取值范围是1-10，超出范围会抛出illegalArgumentException.
在操作系统中，优先级较高的线程获得CPU资源越多
线程优先级本质上只是给线程调度器一个提示信息，以便于调度器决定先调度那些线程，注意不能保证优先级高的线程先运行
java优先级设置不当或者滥用会导致某些线程永远得不到允许，会导致线程饥饿
线程优先级并不是设置的越高越好，一般情况下使用普通的优先级即可，即在开发时不必设置线程的优先级
线程的优先级既有继承性，在A线程中创建了B线程，则B线程的优先级与A线程是一样的

### interrupt()
可以中断线程
调用interrupt()方法仅仅是在当前线程打一个停止标志，并不是真正停止线程
isInterrupted()//判断线程是否被标记为中断

## 线程的生命周期
## 多线程的优势与存储风险
