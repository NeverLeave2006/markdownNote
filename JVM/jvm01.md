# 内存结构

## 1. 程序计数器
program counter register程序计数器(寄存器)
作用:记住下一条指令的执行地址,在CPU中用寄存器实现
特点:
   - 线程私有
   - 唯一不会内存溢出的区

## 2. 虚拟机栈
作用:线程运行时的内存空间,栈内由多个**栈帧**组成
栈帧: 每个方法运行时需要的内存(参数,局部变量,返回地址)
每个线程只有一个活动栈帧,对应当前的正在执行的方法

问题:
1. 垃圾回收是否涉及栈内存?
> 不需要,方法运行完自动弹出!
2. 栈内存分配越打越好吗?
> -Xss: 设置栈大小(stack size)的参数</br>
> 默认大小1024KB(Linux/x64,macOS),Linux根据虚拟内存来影响栈大小</br>
> 实例:</br>
> ```
> -Xss 1m
> -Xss 1024k
> -Xss 1048576
> ```
> 栈越大,线程越小.栈越大,可以多次递归调用!</br>
3. 方法内的局部变量是否线程安全?
> 如果方法内局部变量没有逃离方法内的作用返回,它是线程安全的</br>
> 如果是局部变量引用对象,并逃离了方法的作业范围,需要考虑线程安全

### 栈内存溢出
- 栈帧过多: 递归过多
- 栈帧过大: 

## 线程运行诊断
案例1: cpu占用过多
- top命令,定位占CPU用过高的进程
- ps H -eo pid,tid,%cpu|grep 进程id定位哪个线程引起的cpu占用过高
- jstack命令进程id查看,找对应的线程编号(nid换算),定位代码
  - 可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行数

案例2: 程序运行很长时间没有结果
- jstack对应进程,查死锁

## 3. 本地方法栈


4. 堆

5. 方法区

# 垃圾回收机制